<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chapter 2: Data Structure | Learning R</title>
    <link>//localhost:1313/docs/data_structures/</link>
      <atom:link href="//localhost:1313/docs/data_structures/index.xml" rel="self" type="application/rss+xml" />
    <description>Chapter 2: Data Structure</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Thu, 20 Aug 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>//localhost:1313/images/logo_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_300x300_fit_lanczos_2.png</url>
      <title>Chapter 2: Data Structure</title>
      <link>//localhost:1313/docs/data_structures/</link>
    </image>
    
    <item>
      <title>Basic Data Types</title>
      <link>//localhost:1313/docs/data_structures/basic-data-types/</link>
      <pubDate>Tue, 19 Feb 2019 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/docs/data_structures/basic-data-types/</guid>
      <description>&lt;h2 id=&#34;learning-objectives&#34;&gt;Learning objectives&lt;/h2&gt;
&lt;p&gt;We have seen that we can store objects in the R workspace. In our earlier example, we created variables that would store one piece of information, i.e. a number.&lt;/p&gt;
&lt;p&gt;As you would expect, R can store many different types of data. We call them R basic &lt;em&gt;data types&lt;/em&gt;. We call them &amp;ldquo;basic&amp;rdquo; because they can be assembled into more complex data structures (vectors, arrays, dataframes, etc.) that we will study later.&lt;/p&gt;
&lt;p&gt;In this section you will learn about the basic data types you will be using for our analyses.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#numeric&#34;&gt;Numerics (real numbers) &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#integers&#34;&gt;Integers &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#logicals&#34;&gt;Logicals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#characters&#34;&gt;Characters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#factors&#34;&gt;Factors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;numeric--real-numbers&#34;&gt;Numeric  (&lt;em&gt;real numbers&lt;/em&gt;)&lt;/h2&gt;
&lt;p&gt;Real numbers are stored as &lt;em&gt;numerics&lt;/em&gt; in R. It is the default computational data type.&lt;/p&gt;
&lt;p&gt;If we assign a decimal value to a variable $ x $ as follows, $ x $ will be of numeric type. Note that, even if we assign an integer to a variable $ y $, it is still being saved as a numeric value.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;(x &amp;lt;-  10.5)   # assign a decimal value 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10.5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;class(x)       # print the class name of x 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;numeric&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;y &amp;lt;- 1 
class(y)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;numeric&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The fact that $ y $ is not an integer can be confirmed with the &lt;code&gt;is.integer&lt;/code&gt; function&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;is.integer(y)  # is k an integer? 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;integers&#34;&gt;Integers&lt;/h2&gt;
&lt;p&gt;There are several ways to create an integer variable in R&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;(z &amp;lt;- 3L)  # declare an integer by appending an L suffix
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;is.integer(z)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;(z &amp;lt;- as.integer(3))  # use the as.integer( ) function
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;is.integer(z)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the function &lt;code&gt;as.integer&lt;/code&gt; can coerce a numeric value (or even some character variable) into an integer value.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;(z &amp;lt;- as.integer(3.14))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;is.integer(z)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;(z &amp;lt;- as.integer(&amp;quot;5.27&amp;quot;))  # coerce a decimal string 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;is.integer(z)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;logicals&#34;&gt;Logicals&lt;/h2&gt;
&lt;p&gt;A logical value is either &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A logical is often created via comparison between variables.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- 1; y &amp;lt;- 2   # sample values 
(z &amp;lt;-  x &amp;gt; y)      # is x larger than y? 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;class(z)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;logical&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Standard logical operations are &amp;ldquo;&amp;amp;&amp;rdquo; (and), &amp;ldquo;|&amp;rdquo; (or), and &amp;ldquo;!&amp;rdquo; (negation).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;u &amp;lt;- TRUE; v &amp;lt;- FALSE 
u &amp;amp; v          # u AND v 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;u | v          # u OR v 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;!u             # negation of u 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Further details and related logical operations can be found when typing &lt;code&gt;help(&amp;quot;&amp;amp;&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Finally, it is often useful to perform arithmetic on logical values. You just have to remember that the &lt;code&gt;TRUE&lt;/code&gt; has the value 1, while &lt;code&gt;FALSE&lt;/code&gt; has value 0.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;(as.integer(TRUE))  # is k an integer? 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;TRUE + TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;characters&#34;&gt;Characters&lt;/h2&gt;
&lt;p&gt;In R, strings are stored as a &lt;code&gt;character&lt;/code&gt; object. Strings are surrounded by two &lt;code&gt;&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;(x &amp;lt;- &amp;quot;This is a string&amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;This is a string&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;class(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;character&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you do not use the &lt;code&gt;&amp;quot;&lt;/code&gt;, R will look for a variable instead of a string of characters, and will most likely throw an error message.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;(x &amp;lt;- This is a string) 
class(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Error: &amp;lt;text&amp;gt;:1:12: unexpected symbol
## 1: (x &amp;lt;- This is
##                ^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can convert objects into character values with the &lt;code&gt;as.character()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;(x = as.character(3.14)) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;3.14&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Two character values can be concatenated with the &lt;code&gt;paste()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fname = &amp;quot;Joe&amp;quot;; lname =&amp;quot;Smith&amp;quot; 
paste(fname, lname) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Joe Smith&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To extract a substring, we apply the &lt;code&gt;substr()&lt;/code&gt; function. Here is an example showing how to extract the substring between the third and fourteenth positions in a string.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;substr(&amp;quot;Mary has a little lamb.&amp;quot;, start=3, stop=14) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;ry has a lit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And to replace the first occurrence of the word &amp;ldquo;little&amp;rdquo; by another word &amp;ldquo;big&amp;rdquo; in the string, we apply the &lt;code&gt;sub()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sub(&amp;quot;little&amp;quot;, &amp;quot;big&amp;quot;, &amp;quot;Mary has a little lamb.&amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Mary has a big lamb.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;factors&#34;&gt;Factors&lt;/h2&gt;
&lt;p&gt;With R, factors store categorical variables, i.e. variables that take on a limited number of different values. Categorical variables enter into statistical models differently than continuous variables, so R developers have created a specific data type to insure that the modeling functions will treat such data correctly.&lt;/p&gt;
&lt;p&gt;Practically, factors are stored as a vector of integer values with a corresponding set of character values to use when the factor is displayed.&lt;/p&gt;
&lt;p&gt;Use the function &lt;code&gt;factor()&lt;/code&gt; to create a factor. The only required argument to factor is a vector of values which will be returned as a vector of factor values. Both numeric and character variables can be made into factors, but a factor&amp;rsquo;s levels will always be character values. You can see the possible levels for a factor through the &lt;code&gt;levels()&lt;/code&gt; command.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Transform character vector into a factor
data = c(&amp;quot;a&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;)
fdata = factor(data)
fdata
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] a c b a a b
## Levels: a b c
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Transform numeric vector into a factor
data = c(1,2,2,3,1,2,3,3,1,2,3,3,1)
fdata = factor(data)
fdata
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 1 2 2 3 1 2 3 3 1 2 3 3 1
## Levels: 1 2 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The levels of a factor are used when displaying the factor&amp;rsquo;s values. You can change these levels at the time you create a factor by passing a vector with the new values through the &lt;code&gt;labels= argument&lt;/code&gt;. Note that this actually changes the internal levels of the factor, and to change the labels of a factor after it has been created, the assignment form  (&lt;code&gt;&amp;lt;-&lt;/code&gt;) of the levels function is used.&lt;/p&gt;
&lt;p&gt;To convert the default factor fdata we use the assignment form of the levels function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;data = c(1,2,2,3,1,2,3,3,1,2,3,3,1)

#define specific labels when constructing the factor
fdata = factor(data, labels = c(&amp;quot;Weak&amp;quot;, &amp;quot;Mild&amp;quot;, &amp;quot;Strong&amp;quot;)) 
fdata
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] Weak   Mild   Mild   Strong Weak   Mild   Strong Strong Weak   Mild  
## [11] Strong Strong Weak  
## Levels: Weak Mild Strong
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#re-define labels after construction
levels(fdata) = c(&#39;I&#39;,&#39;II&#39;,&#39;III&#39;)
fdata
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] I   II  II  III I   II  III III I   II  III III I  
## Levels: I II III
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Factors are an efficient way to store character values, because each unique character value is stored only once, and the data itself is stored as a vector of integers.&lt;/p&gt;
&lt;p&gt;To change the order in which the levels will be displayed from their default sorted order, the levels= argument can be given a vector of all the possible values of the variable in the order you desire.&lt;/p&gt;
&lt;p&gt;Consider some data consisting of the names of months:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;theMonths = c(&amp;quot;March&amp;quot;,&amp;quot;April&amp;quot;,&amp;quot;January&amp;quot;,&amp;quot;November&amp;quot;,&amp;quot;January&amp;quot;,
 &amp;quot;September&amp;quot;,&amp;quot;October&amp;quot;,&amp;quot;September&amp;quot;,&amp;quot;November&amp;quot;,&amp;quot;August&amp;quot;,
 &amp;quot;January&amp;quot;,&amp;quot;November&amp;quot;,&amp;quot;November&amp;quot;,&amp;quot;February&amp;quot;,&amp;quot;May&amp;quot;,&amp;quot;August&amp;quot;,
 &amp;quot;July&amp;quot;,&amp;quot;December&amp;quot;,&amp;quot;August&amp;quot;,&amp;quot;August&amp;quot;,&amp;quot;September&amp;quot;,&amp;quot;November&amp;quot;,
 &amp;quot;February&amp;quot;,&amp;quot;April&amp;quot;)
 theMonths = factor(theMonths)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, the levels will be presented using alphabetic order, which in the case of Months will make readings of results a bit difficult when summarizing information.&lt;/p&gt;
&lt;p&gt;For example, the function &lt;code&gt;table()&lt;/code&gt; will tell us how many times each month has appeared in our vector theMonths&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;table(theMonths)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## theMonths
##     April    August  December  February   January      July     March       May 
##         2         4         1         2         3         1         1         1 
##  November   October September 
##         5         1         3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although the months clearly have an ordering, this is not reflected in the output of the table function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;theMonths &amp;lt;- factor(theMonths,levels=c(&amp;quot;January&amp;quot;,&amp;quot;February&amp;quot;,&amp;quot;March&amp;quot;,
             &amp;quot;April&amp;quot;,&amp;quot;May&amp;quot;,&amp;quot;June&amp;quot;,&amp;quot;July&amp;quot;,&amp;quot;August&amp;quot;,&amp;quot;September&amp;quot;,
             &amp;quot;October&amp;quot;,&amp;quot;November&amp;quot;,&amp;quot;December&amp;quot;))

table(theMonths)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## theMonths
##   January  February     March     April       May      June      July    August 
##         3         2         1         2         1         0         1         4 
## September   October  November  December 
##         3         1         5         1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;theMonths[2] &amp;gt; theMonths[3]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in Ops.factor(theMonths[2], theMonths[3]): &#39;&amp;gt;&#39; not meaningful for
## factors
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As the results of the last operation shows, the comparison operators are not supported for unordered factors. Creating an ordered factor solves this problem:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;theMonths &amp;lt;- factor(theMonths,levels=c(&amp;quot;January&amp;quot;,&amp;quot;February&amp;quot;,&amp;quot;March&amp;quot;,
             &amp;quot;April&amp;quot;,&amp;quot;May&amp;quot;,&amp;quot;June&amp;quot;,&amp;quot;July&amp;quot;,&amp;quot;August&amp;quot;,&amp;quot;September&amp;quot;,
             &amp;quot;October&amp;quot;,&amp;quot;November&amp;quot;,&amp;quot;December&amp;quot;), ordered = TRUE)

table(theMonths)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## theMonths
##   January  February     March     April       May      June      July    August 
##         3         2         1         2         1         0         1         4 
## September   October  November  December 
##         3         1         5         1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;theMonths[2] &amp;gt; theMonths[3]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another common way to create factors is to split a continuous variables into intervals using the &lt;code&gt;cut&lt;/code&gt; function. The &lt;code&gt;breaks= argument&lt;/code&gt; to cut is used to describe how ranges of numbers will be converted to factor values. If a number is provided through the &lt;code&gt;breaks= argument&lt;/code&gt;, the resulting factor will be created by dividing the range of the variable into that number of equal length intervals; if a vector of values is provided, the values in the vector are used to determine the breakpoint. Note that if a vector of values is provided, the number of levels of the resultant factor will be one less than the number of values in the vector.&lt;/p&gt;
&lt;p&gt;For example, consider the women data set, which contains height and weights for a sample of women. If we wanted to create a factor corresponding to weight, with three equally-spaced levels, we could use the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;data(&amp;quot;women&amp;quot;)
wfact = cut(women$height,3)
wfact
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] (58,62.7]   (58,62.7]   (58,62.7]   (58,62.7]   (58,62.7]   (62.7,67.3]
##  [7] (62.7,67.3] (62.7,67.3] (62.7,67.3] (62.7,67.3] (67.3,72]   (67.3,72]  
## [13] (67.3,72]   (67.3,72]   (67.3,72]  
## Levels: (58,62.7] (62.7,67.3] (67.3,72]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;table(wfact)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## wfact
##   (58,62.7] (62.7,67.3]   (67.3,72] 
##           5           5           5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;labels= argument&lt;/code&gt; to cut allows you to specify the levels of the factors, instead of the intervals&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;wfact = cut(women$height,3,labels=c(&#39;Low&#39;,&#39;Medium&#39;,&#39;High&#39;))
table(wfact)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## wfact
##    Low Medium   High 
##      5      5      5
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Vectors</title>
      <link>//localhost:1313/docs/data_structures/vectors/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/docs/data_structures/vectors/</guid>
      <description>&lt;h2 id=&#34;learning-objectives&#34;&gt;Learning objectives&lt;/h2&gt;
&lt;p&gt;In this section you will learn about vectors, how to create different types of vector, and how to manipulate them.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#numeric-vectors&#34;&gt;Numeric Vectors: Definition and Creation &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#generating-regular-sequences&#34;&gt;Generating regular sequences &lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#the-colon-operator&#34;&gt;The : operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#the-seq-function&#34;&gt;The seq() function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#the-rep-function&#34;&gt;The rep() function&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#vector-arithmetic&#34;&gt;Vector Arithmetic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#useful-functions-applied-to-a-vector&#34;&gt;Useful functions applied to a vector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#vectors-with-other-types-of-data&#34;&gt;Vectors with other types of data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#automatic-coercing-within-vectors&#34;&gt;Automatic coercing within vectors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;numeric-vectors&#34;&gt;Numeric vectors&lt;/h2&gt;
&lt;p&gt;R operates on named data structures. The simplest data structure is the numeric vector: a single entity consisting of an &lt;em&gt;ordered collection of numbers&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To set up a vector, we use the R function &lt;code&gt;c()&lt;/code&gt; which, in this context, can take an arbitrary number of arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(10.4, 5.6, 3.1, 6.4, 21.7)
x
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10.4  5.6  3.1  6.4 21.7
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;class(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;numeric&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also use the function &lt;code&gt;c()&lt;/code&gt; to concatenate several existing vectors&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(10.4, 5.6, 3.1 )
y &amp;lt;- c(2,3,4)
z &amp;lt;- c(x,y)
z
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10.4  5.6  3.1  2.0  3.0  4.0
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;class(z)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;numeric&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;generating-regular-sequences&#34;&gt;Generating regular sequences&lt;/h2&gt;
&lt;p&gt;R has also a number of built-in functions for generating commonly used sequences of numbers.&lt;/p&gt;
&lt;h3 id=&#34;the-colon-operator-&#34;&gt;The colon operator &lt;code&gt;:&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;:&lt;/code&gt;  creates regular sequence of integers. Its syntax is quite intuite: to create a regular sequence of integers from 1 to 10, just type:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;1:10
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  1  2  3  4  5  6  7  8  9 10
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;15:5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 15 14 13 12 11 10  9  8  7  6  5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The colon operator has high priority within an expression. Check the results of the following expressions to understand the order in which the operators are working:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;2*1:15
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;n &amp;lt;- 10
1:n-1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0 1 2 3 4 5 6 7 8 9
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;1:(n-1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 4 5 6 7 8 9
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;the-seq-function&#34;&gt;The &lt;code&gt;seq()&lt;/code&gt; function&lt;/h3&gt;
&lt;p&gt;The function seq() is more general. 
It has five arguments, only some of which may be specified in any one call. Consult the help file for more details. Look at the few examples to understand the function seq()&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;seq(1, 2, by=.2) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.0 1.2 1.4 1.6 1.8 2.0
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;seq(length=10, from =-1, by=2)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] -1  1  3  5  7  9 11 13 15 17
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;the-rep-function&#34;&gt;The &lt;code&gt;rep()&lt;/code&gt; function&lt;/h3&gt;
&lt;p&gt;The function rep() can be used for replicating an object in several ways and creating vectors.&lt;/p&gt;
&lt;p&gt;To put, several copies end-to-end, use the argument &lt;code&gt;times&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(1.34, 2.56)
(s5 &amp;lt;- rep(x, times=5))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 1.34 2.56 1.34 2.56 1.34 2.56 1.34 2.56 1.34 2.56
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To repeat each element of x five times before moving on to the next, use the argument &lt;code&gt;each&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;(s6 &amp;lt;- rep(x, each=3))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.34 1.34 1.34 2.56 2.56 2.56
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;vector-arithmetic&#34;&gt;Vector arithmetic&lt;/h2&gt;
&lt;p&gt;Vectors can be used in arithmetic expressions, in which case the operations are performed &lt;strong&gt;element by element&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;For example, if you add two vectors:&lt;/p&gt;
&lt;p&gt;\begin{equation}
\left(\begin{matrix}a\\b\\c\\d \end{matrix} \right)  + 
\left(\begin{matrix}e\\f\\g\\h  \end{matrix} \right) =
\left(\begin{matrix}a+e\\b+f\\c+g\\d+h \end{matrix} \right) 
\end{equation}&lt;/p&gt;
&lt;p&gt;In R:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(10.4, 5.6, 3.4)
y &amp;lt;- c(3.1, 6.4, -2.1)
(z &amp;lt;- x + y)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 13.5 12.0  1.3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, vectors occurring in the same expression do not need to be of the same length. If they are not, the value of the expression is a vector with the same length as the longest vector which occurs in the expression. Shorter vectors in the expression are recycled as often as need be (perhaps fractionally) until they match the length of the longest vector. 
In particular a constant is simply repeated.&lt;/p&gt;
&lt;p&gt;For example: 
\begin{equation}
\left(\begin{matrix}a\\b\\c \end{matrix} \right)  +  e =
\left(\begin{matrix}a+e\\b+e\\c+e \end{matrix} \right) 
\end{equation}&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(10.4, 5.6)
y &amp;lt;- 3.1
(z &amp;lt;- x + y)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 13.5  8.7
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;While this is a very convenient R feature, it can be potentially misleading as it brings unruly results when the vectors are of different length, as in the following case:&lt;/p&gt;
&lt;p&gt;\begin{equation}
\left(\begin{matrix}a\\b\\c\\d \end{matrix} \right)  +&lt;br&gt;
\left(\begin{matrix}e\\f\\g \end{matrix} \right) =
\left(\begin{matrix}a+e\\b+f\\c+g\\d+e \end{matrix} \right) 
\end{equation}&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(10.4, 5.6, 3.5)
y &amp;lt;- c(1,2)
z &amp;lt;- x + y
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in x + y: longer object length is not a multiple of shorter object
## length
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;z
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 11.4  7.6  4.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just to remind you of the potential danger, R will throw a warning message&lt;/p&gt;
&lt;p&gt;The elementary arithmetic operators are the usual +, -, *, / and ^ for raising to a power. In addition all of the common arithmetic functions are available. &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt; and so on, all have their usual meaning.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(10.4, 5.6, 3.5)
log(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.341806 1.722767 1.252763
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; select the largest and smallest elements of a vector respectively.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;min(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3.5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;useful-functions-applied-to-a-vector&#34;&gt;Useful functions applied to a vector&lt;/h2&gt;
&lt;p&gt;Several functions are very useful for basic statistics.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;sum()&lt;/code&gt; function, sums up all the elements of the vector. The &lt;code&gt;mean()&lt;/code&gt; function calculates the mean value of all the elements of the vector. We can combine vector arithmetics with these functions to calculate very quickly some interesting statistics of the vector.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(10.4, 5.6, 3.5, 3.1, 7.2, 3.8, 10.2, 7.8)
mean(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 6.45
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x - mean(x)  #calculate the deviation from the mean
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  3.95 -0.85 -2.95 -3.35  0.75 -2.65  3.75  1.35
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can calculate easily the sample variance 
$$ var(x) = \frac{1}{n-1} \sum_{i=1}^n (x_i - \bar{x})^2 $$&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(10.4, 5.6, 3.5, 3.1, 7.2, 3.8, 10.2, 7.8)
mean(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 6.45
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;v&amp;lt;- sum((x - mean(x))^2) / (length(x)-1)  #calculate the variance
v
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 8.531429
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;var(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 8.531429
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that base R already has a built-in function for calculating the sample variance &lt;code&gt;var()&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;vectors-with-other-types-of-data&#34;&gt;Vectors with other types of data&lt;/h2&gt;
&lt;p&gt;Vectors can contain other types of data, in particular characters and logicals.&lt;/p&gt;
&lt;p&gt;The elements of a logical vector can have the values &lt;code&gt;TRUE&lt;/code&gt;, &lt;code&gt;FALSE&lt;/code&gt;, and &lt;code&gt;NA&lt;/code&gt; (for &amp;ldquo;not available&amp;rdquo;). The first two are often abbreviated as T and F, respectively. Note however that T and F are just variables which are set to TRUE and FALSE by default, but are not reserved words and hence can be overwritten by the user. &lt;strong&gt;Hence, it is better to always use TRUE and FALSE.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;automatic-coercing-within-vectors&#34;&gt;Automatic coercing within vectors&lt;/h2&gt;
&lt;p&gt;In general, coercion is an attempt by R to be flexible with data types. When an entry does not match the expected type, R tries to guess what we meant. But this can also lead to confusion.&lt;/p&gt;
&lt;p&gt;We earlier said that vectors must be all of the same type.
So if we try to combine say numbers and characters, you might expect an error. But let&amp;rsquo;s try to combine numeric and characters in the same vector:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;c(1, &amp;quot;South Africa&amp;quot;, 3, &amp;quot;England&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;1&amp;quot;            &amp;quot;South Africa&amp;quot; &amp;quot;3&amp;quot;            &amp;quot;England&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We do not even get a warning !! So what has happened?&lt;/p&gt;
&lt;p&gt;R has converted the 1 and the 3 to character strings. And the class of the vector is character. Even though 1 and 3 were originally numbers when we wrote it out, R has converted them to character.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;R coerced the data into a character string.&lt;/em&gt; It guessed that because we put a character string there in the middle, we meant the 1 and the 3 to actually also be character strings.&lt;/p&gt;
&lt;p&gt;Again, be aware that R will coerce variables without any warning !
It will only throw an error, when it attemps to coerce a variable into a new type, but cannot do it.&lt;/p&gt;
&lt;h2 id=&#34;index-vectors-to-obtain-subsets-of-a-vector&#34;&gt;Index vectors to obtain subsets of a vector&lt;/h2&gt;
&lt;p&gt;Subsets of the elements of a vector may be selected by appending to the name of the vector an &lt;em&gt;index vector&lt;/em&gt; in square brackets. More generally any expression that evaluates to a vector may have subsets of its elements similarly selected by appending an index vector in square brackets immediately after the expression.&lt;/p&gt;
&lt;p&gt;Such index vectors can be any of four distinct types.&lt;/p&gt;
&lt;h3 id=&#34;index--a-logical-vector&#34;&gt;Index = A logical vector.&lt;/h3&gt;
&lt;p&gt;In this case the index vector is recycled to the same length as the vector from which elements are to be selected. Values corresponding to TRUE in the index vector are selected and those corresponding to FALSE are omitted. For example, the following lines reates (or re-creates) an object `yv which will contain the values of x greater than 4, in the same order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;y &amp;lt;- x[x &amp;gt; 4]
y
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10.4  5.6  7.2 10.2  7.8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;index--a-vector-of-integers&#34;&gt;Index = A vector of integers.&lt;/h3&gt;
&lt;p&gt;In this case the values in the index vector must lie in the set {1, 2, …, length(x)}. The corresponding elements of the vector are selected and concatenated, in that order, in the result. The index vector can be of any length and the result is of the same length as the index vector.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- rnorm(20)
(y &amp;lt;- x[1:10])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  0.09220648  1.12491187  0.53665207  1.81840151 -0.38831663  0.06935517
##  [7] -2.59814157 -0.20936368  0.94048022 -0.27008015
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;(z &amp;lt;- x[c(1,3,2,7)])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  0.09220648  0.53665207  1.12491187 -2.59814157
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The use of index vectors can be very powerful to create complex sequences:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;c(&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;)[rep(c(1,2,2,1), times=2)]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;x&amp;quot; &amp;quot;y&amp;quot; &amp;quot;y&amp;quot; &amp;quot;x&amp;quot; &amp;quot;x&amp;quot; &amp;quot;y&amp;quot; &amp;quot;y&amp;quot; &amp;quot;x&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;index--a-vector-of-negative-integers&#34;&gt;Index = A vector of negative Integers&lt;/h3&gt;
&lt;p&gt;Such an index vector specifies the values &lt;em&gt;to be excluded&lt;/em&gt; rather than included. Thus:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x[-(1:5)]  # gives y all but the first five elements of x.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  0.06935517 -2.59814157 -0.20936368  0.94048022 -0.27008015  1.94953530
##  [7] -1.46875658  1.35834277 -1.23067250 -0.54102607 -0.55928871  0.62858631
## [13] -0.97861047  0.98952395 -1.33371635
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;index--a-vector-of-character-strings&#34;&gt;Index = A vector of character strings.&lt;/h3&gt;
&lt;p&gt;This possibility only applies where an object has a names attribute to identify its components. In this case a sub-vector of the names vector may be used in the same way as the positive integral labels in item 2 further above.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fruit &amp;lt;- c(5, 10, 1, 20)
names(fruit) &amp;lt;- c(&amp;quot;orange&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;apple&amp;quot;, &amp;quot;peach&amp;quot;)
lunch &amp;lt;- fruit[c(&amp;quot;apple&amp;quot;,&amp;quot;orange&amp;quot;)]
lunch
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  apple orange 
##      1      5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note in this case, that we added a feature to the vector, because each element of the vector is associated with a name. This is obtained by using the function &lt;code&gt;names()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The advantage is that alphanumeric names are often easier to remember than numeric indices.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Matrices</title>
      <link>//localhost:1313/docs/data_structures/matrices/</link>
      <pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/docs/data_structures/matrices/</guid>
      <description>&lt;h2 id=&#34;learning-objectives&#34;&gt;Learning objectives&lt;/h2&gt;
&lt;p&gt;In this section you will learn about matrices, how to create and manipulate them.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#what-is-a-matrix&#34;&gt;What is a matrix? &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#create-a-matrix&#34;&gt;Create a matrix &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#access-elements-of-a-matrix&#34;&gt;Access elements of a matrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#matrix-calculations&#34;&gt;Matrix calculations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#common-matrix-functions&#34;&gt;Common matrix functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;what-is-a-matrix&#34;&gt;What is a matrix&lt;/h2&gt;
&lt;p&gt;A matrix is a collection of data elements &lt;strong&gt;of the same basic type&lt;/strong&gt; arranged in a two-dimensional rectangular layout.&lt;/p&gt;
&lt;p&gt;\begin{pmatrix}
x_{11} &amp;amp; x_{12} &amp;amp; x_{13} &amp;amp; \dots  &amp;amp; x_{1n} \\&lt;br&gt;
x_{21} &amp;amp; x_{22} &amp;amp; x_{23} &amp;amp; \dots  &amp;amp; x_{2n} \\&lt;br&gt;
\vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\&lt;br&gt;
x_{d1} &amp;amp; x_{d2} &amp;amp; x_{d3} &amp;amp; \dots  &amp;amp; x_{dn}
\end{pmatrix}&lt;/p&gt;
&lt;p&gt;We can create a matrix containing only characters or only logical values. However, it is most common to use matrices containing numeric elements for mathematical calculations.&lt;/p&gt;
&lt;h2 id=&#34;create-a-matrix&#34;&gt;Create a matrix&lt;/h2&gt;
&lt;h3 id=&#34;using-the-matrix-function&#34;&gt;Using the &lt;code&gt;matrix()&lt;/code&gt; function&lt;/h3&gt;
&lt;p&gt;A matrix can be created directly using the &lt;code&gt;matrix(data, nrow, ncol, byrow, dimnames)&lt;/code&gt; function, where&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;data&lt;/em&gt; is an input vector which becomes the data elements of the matrix.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;nrow&lt;/em&gt; is the number of rows to be created.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ncol&lt;/em&gt; is the number of columns to be created.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;byrow&lt;/em&gt; is a logical. If TRUE then the input vector elements are arranged by row.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;dimnames&lt;/em&gt; is the names assigned to the rows and columns.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the following example, we are first creating a vector with 12 values that we feed as an argument to the function &lt;code&gt;matrix()&lt;/code&gt;. Note that once I gave the one of the two arguments, nrow or ncol, the other one is deducted by the function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Elements are arranged sequentially by row.
# Note: you do not have to enter all the arguments
ans &amp;lt;- matrix(c(1:12), nrow = 4, byrow = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To see the effect of the argument &lt;code&gt;byrow&lt;/code&gt;, you can compare the above matrix with another matrix where you gave the argument &lt;code&gt;byrow=FALSE&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;Be aware that matrix() will only issue a warning if the vector length is not a multiple of the number of rows. In such case, the last row of the matrix will be completed with the first components of the vector: this is very unlikely it was the matrix you wanted to work with.&lt;/p&gt;
&lt;p&gt;Look at what happens in the following example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Elements are arranged sequentially by row.
# Note: you do not have to enter all the arguments
ans &amp;lt;- matrix(c(1:14), nrow = 4, byrow = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in matrix(c(1:14), nrow = 4, byrow = TRUE): data length [14] is not a
## sub-multiple or multiple of the number of rows [4]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ans
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    5    6    7    8
## [3,]    9   10   11   12
## [4,]   13   14    1    2
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The names of the rows and the columns should appear as a list of two vectors. (more on lists later)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Define the column and row names.
rownames &amp;lt;- c(&amp;quot;row1&amp;quot;, &amp;quot;row2&amp;quot;, &amp;quot;row3&amp;quot;, &amp;quot;row4&amp;quot;)
colnames &amp;lt;- c(&amp;quot;col1&amp;quot;, &amp;quot;col2&amp;quot;, &amp;quot;col3&amp;quot;)

matrix(c(1:12), nrow = 4, byrow = TRUE, dimnames = list(rownames, colnames))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      col1 col2 col3
## row1    1    2    3
## row2    4    5    6
## row3    7    8    9
## row4   10   11   12
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;using-cbind-and-rbind-functions&#34;&gt;Using cbind() and rbind() functions&lt;/h3&gt;
&lt;p&gt;You can also create a matrix by collating (binding) vectors together. Examples below show you different way to create column, row or rectangular matrices with &lt;code&gt;cbind&lt;/code&gt; and &lt;code&gt;rbind&lt;/code&gt; functions.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#create a three columns matrix from a vector
rbind(1:3)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]    1    2    3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ans &amp;lt;- cbind(rep(0, 3))
ans
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1]
## [1,]    0
## [2,]    0
## [3,]    0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can create a rectangular matrix, binding several vectors of the same size&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cbind(1:3, 4:6, 7:9)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;Note that the &lt;code&gt;cbind&lt;/code&gt; and &lt;code&gt;rbind&lt;/code&gt; functions can be used to combine matrices. But you have to make sure the matrices have compatible dimensions&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A &amp;lt;- matrix(1:12, ncol=3); A
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;B &amp;lt;- matrix(1:9, ncol=3); B
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# the matrices A and B have the same number of columns
# you can combine the using rbind()
rbind(A, B)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12
## [5,]    1    4    7
## [6,]    2    5    8
## [7,]    3    6    9
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# But it will throw an error if we use cbind
cbind(A, B)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Error in cbind(A, B): number of rows of matrices must match (see arg 2)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;using-specialized-functions&#34;&gt;Using specialized functions&lt;/h3&gt;
&lt;p&gt;The function diag() is very handy to create an identity matrix of a given size&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;diag(4)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    0    0    0
## [2,]    0    1    0    0
## [3,]    0    0    1    0
## [4,]    0    0    0    1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;access-elements-of-a-matrix&#34;&gt;Access elements of a matrix&lt;/h2&gt;
&lt;p&gt;What you&amp;rsquo;ve learned for vectors can be applied for matrices. Just remember that the first index is for the rows, and the second index is for the columns.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ans &amp;lt;- matrix(1:12, nrow = 3)
ans
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   10
## [2,]    2    5    8   11
## [3,]    3    6    9   12
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ans[1, 3] # will return the element in row 1 and column 3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 7
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ans[1,]  #will return the first row
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  1  4  7 10
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ans[,2] # will return the second column
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4 5 6
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ans[, 1:2] #will return the first two columns
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also create a boolean matrix and use it to screen out the elements&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;indices &amp;lt;- ans &amp;gt; 5   #will create a boolean matrix
indices  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       [,1]  [,2] [,3] [,4]
## [1,] FALSE FALSE TRUE TRUE
## [2,] FALSE FALSE TRUE TRUE
## [3,] FALSE  TRUE TRUE TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ans[indices]  # will return a vector 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  6  7  8  9 10 11 12
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;matrix-calculations&#34;&gt;Matrix calculations&lt;/h2&gt;
&lt;h3 id=&#34;multiplication-by-a-scalar&#34;&gt;Multiplication by a Scalar&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A &amp;lt;- matrix(1:12, ncol=4, byrow=FALSE); A
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   10
## [2,]    2    5    8   11
## [3,]    3    6    9   12
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A * 0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]  0.1  0.4  0.7  1.0
## [2,]  0.2  0.5  0.8  1.1
## [3,]  0.3  0.6  0.9  1.2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;matrix-addition--subtraction&#34;&gt;Matrix Addition &amp;amp; Subtraction&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;B &amp;lt;- matrix(2:13, ncol=4, byrow=FALSE); B
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    2    5    8   11
## [2,]    3    6    9   12
## [3,]    4    7   10   13
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A + B
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    3    9   15   21
## [2,]    5   11   17   23
## [3,]    7   13   19   25
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A - B
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]   -1   -1   -1   -1
## [2,]   -1   -1   -1   -1
## [3,]   -1   -1   -1   -1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;element-wise-multiplication&#34;&gt;Element-wise multiplication&lt;/h3&gt;
&lt;h1 id=&#34;endpmatrix&#34;&gt;[
&lt;code&gt;\begin{pmatrix} x_{11} &amp;amp; x_{12}  \\ x_{21} &amp;amp; x_{22}   \end{pmatrix}&lt;/code&gt;
\times
&lt;code&gt;\begin{pmatrix} y_{11} &amp;amp; y_{12}  \\ y_{21} &amp;amp; y_{22}   \end{pmatrix}&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;\begin{pmatrix} x_{11} \times y_{11} &amp;amp; x_{12} \times y_{12}   \\ x_{21} \times y_{21} &amp;amp; x_{22} \times y_{22}  \end{pmatrix}&lt;/code&gt;
]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A*B
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    2   20   56  110
## [2,]    6   30   72  132
## [3,]   12   42   90  156
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;transpose-of-a-matrix&#34;&gt;Transpose of a matrix&lt;/h3&gt;
&lt;h1 id=&#34;endpmatrix-1&#34;&gt;\begin{pmatrix}
x_{11} &amp;amp; x_{12}  \&lt;br&gt;
x_{21} &amp;amp; x_{22}&lt;br&gt;
\end{pmatrix}&amp;rsquo;&lt;/h1&gt;
&lt;p&gt;\begin{pmatrix}
y_{11} &amp;amp; x_{21}  \&lt;br&gt;
x_{12} &amp;amp; x_{22}&lt;br&gt;
\end{pmatrix}&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;BT &amp;lt;- t(B); BT 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]    2    3    4
## [2,]    5    6    7
## [3,]    8    9   10
## [4,]   11   12   13
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;matrix-multiplication&#34;&gt;Matrix multiplication&lt;/h3&gt;
&lt;p&gt;With two conformable matrices, the matrice multiplication is done with the operator &lt;code&gt;%*%&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;endpmatrix-2&#34;&gt;\begin{pmatrix}
x_{11} &amp;amp; x_{12} &amp;amp; x_{13}  \&lt;br&gt;
x_{21} &amp;amp; x_{22} &amp;amp; x_{23} 
\end{pmatrix}
.
\begin{pmatrix}
y_{11} &amp;amp; y_{12}  \&lt;br&gt;
y_{21} &amp;amp; y_{22}  \&lt;br&gt;
y_{31} &amp;amp; y_{32}&lt;br&gt;
\end{pmatrix}&lt;/h1&gt;
&lt;p&gt;\begin{pmatrix}
x_{11}.y_{11} + x_{12} . y_{21} + x_{13}.y_{31}  &amp;amp; 
x_{21}.y_{12} + x_{22}.y_{22} + x_{23}.y_{32}  \\ 
x_{11}.y_{11} + x_{12}.y_{21} + x_{13}.y_{31} &amp;amp; 
x_{21}.y_{12} + x_{22}.y_{22} + x_{23}.y_{32}
\end{pmatrix}&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   10
## [2,]    2    5    8   11
## [3,]    3    6    9   12
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;BT
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]    2    3    4
## [2,]    5    6    7
## [3,]    8    9   10
## [4,]   11   12   13
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A %*% BT
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,]  188  210  232
## [2,]  214  240  266
## [3,]  240  270  300
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This operator also allows the multiplication of a matrix by a vector.&lt;/p&gt;
&lt;h1 id=&#34;endpmatrix-3&#34;&gt;\begin{pmatrix}
x_{11} &amp;amp; x_{12}  \&lt;br&gt;
x_{21} &amp;amp; x_{22}&lt;br&gt;
\end{pmatrix}
.
\begin{pmatrix}
y_1  \&lt;br&gt;
y_2&lt;br&gt;
\end{pmatrix}&lt;/h1&gt;
&lt;p&gt;\begin{pmatrix}
x_{11} . y_1 + x_{12} . y_2   \&lt;br&gt;
x_{21} . y_1 + x_{22} . y_2 
\end{pmatrix}&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A &amp;lt;- matrix(1:4, ncol=2); A
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;V &amp;lt;- c(2,5); V
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2 5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A %*% V
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1]
## [1,]   17
## [2,]   24
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;common-matrix-functions&#34;&gt;Common matrix functions&lt;/h2&gt;
&lt;p&gt;For a matrix A&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A &amp;lt;- matrix(seq(2, 8, 2), ncol=2); A
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]    2    6
## [2,]    4    8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;number-of-rows-and-columns&#34;&gt;Number of Rows and Columns&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dim(A)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2 2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;nrow(A)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ncol(A)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;diagonal-elements&#34;&gt;Diagonal elements&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;diag(A)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2 8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;determinant&#34;&gt;Determinant&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;det(A)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;eigenvalues-and-eigenvectors&#34;&gt;Eigenvalues and eigenvectors&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;eigA &amp;lt;- eigen(A); eigA
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## eigen() decomposition
## $values
## [1] 10.7445626 -0.7445626
## 
## $vectors
##            [,1]       [,2]
## [1,] -0.5657675 -0.9093767
## [2,] -0.8245648  0.4159736
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the output of the function eigen is a list. If you are only interested by the eigenvalues, just use&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;eigA &amp;lt;- eigen(A) 
eigA$values
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10.7445626 -0.7445626
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;inverse&#34;&gt;Inverse&lt;/h3&gt;
&lt;p&gt;if A is a regular matrix (square and inversible), the inverse is found using the function &lt;code&gt;solve()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;invA &amp;lt;- solve(A); invA
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1]  [,2]
## [1,] -1.0  0.75
## [2,]  0.5 -0.25
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;invA %*% A
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]    1    0
## [2,]    0    1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;A %*% invA
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]    1    0
## [2,]    0    1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;computing-column-and-row-sums&#34;&gt;Computing Column and Row Sums&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;colSums(A)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  6 14
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;rowSums(A)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  8 12
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sum(A)  #total over all elements
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 20
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
